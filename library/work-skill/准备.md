vue2
diff算法
1. **创建新的虚拟DOM：** 首先，Vue.js会根据最新的状态数据生成新的虚拟DOM树。
    
2. **比较新旧虚拟DOM：** 然后，Vue.js会对新的虚拟DOM树和旧的虚拟DOM树进行深度优先遍历，比较它们的差异。
    
3. **更新真实DOM：** 在比较过程中，Vue.js会根据差异（补丁）来更新真实DOM。对于需要更新的节点，Vue.js会将新的节点替换旧的节点，或者更新节点的属性和文本内容，从而使得真实DOM与最新的状态数据保持一致。
    
4. **避免跨级更新：** 在比较过程中，Vue.js会尽量避免跨级更新，即不同层级之间的节点比较。Vue.js会通过一些优化策略，如设置唯一的key值、使用相同的标签名等，来最小化跨级更新的次数，减少不必要的性能损耗。
    
5. **复用已有节点：** 在比较过程中，Vue.js会尽量复用已有的节点，减少创建和销毁节点的开销。如果新旧节点相同，Vue.js会复用已有的节点，而不是创建新的节点。
    
6. **更新子组件：** 在比较过程中，Vue.js也会对子组件进行递归比较和更新，从而保持整个组件树的一致性

vue3算法的原理 和2的区别

**Vue 3 的虚拟 DOM 优化：**

- **静态树提升：** Vue 3 通过静态树提升（Static Tree Hoisting）优化了渲染性能。静态树提升将静态的部分提升为常量，避免不必要的重新渲染和对比。
    
- **Fragment 支持：** Vue 3 支持 Fragment，可以直接返回多个相邻的根节点，而无需额外的容器元素。
    
- **Teleport 组件：** Vue 3 引入了 Teleport 组件，可以将子节点渲染到 DOM 中的任意位置，避免了重新创建组件实例的开销。
    

**2. Vue 3 的 diff 算法改进：**

- **递归静态提升：** Vue 3 的 diff 算法在比较新旧节点时，会首先对静态节点进行提升，避免不必要的对比。
    
- **跳过静态子树：** 当比较新旧节点时，如果新旧节点都是静态节点，Vue 3 的 diff 算法会直接跳过这部分子树的比较，减少了不必要的操作。
    
- **Fragments 的优化：** 在比较 Fragments 时，Vue 3 的 diff 算法会考虑到子节点的 key，从而更精准地判断是否需要重新渲染。
    

**3. Vue 3 的动态路由批处理：**

- Vue 3 通过动态路由批处理（Dynamic Routing Batching）机制来优化渲染性能。该机制将多个路由的渲染操作合并为一次，减少了不必要的渲染和对比。



 - 双向数据绑定核心原理  - mvvm理解
     - 单向绑定 model view  数据模型绑定到view   data变了 view也得变
     - 双向绑定 view变了 data也更新
     - 双向绑定 包含
      1. 数据层 model 存储数据及业务逻辑
      2. 视图层 view 展示效果
      3. 业务逻辑层 viewmodel 数据和视图相关联
      mvvm model viewmodel view
      
	通过object.defineProperty()的get和set实现数据劫持 非侵入式改变 get
	和set需要全局变量存取修改值 通过defineReactive 形成一个闭包环境记录上一次的值
	通过object.defineProperty()去读取修改值
	oberver一个对象 从外到内的观察每一层的对象的值
	数组的响应式 以array的protptype为原型通过object.setPrototypeof改写原型 改写push pop slice splice sort reverse shift七个方法
	备份原来的方法 定义新的方法


  viewmodel 
	1. observer 对所有数据的属性进行监听
	2. compiler 解析器 将我们的指令解析生效更新
    new Vue()
    1. data observer 响应式处理
    2. template 动态绑定的数据 ({})->data获取的数据和 view关联= compiler
    3. update watcher
    4. data有变化 找dep--》watcher ->update


    new MVVM()
    observer 劫持监听所有的属性 通知变化dep -》watcher》视图更新 update
    compiler： 订阅数据变化 绑定到watcher上
    
    
手写一个vue
    ```
```
class Vue{
  constructor(options){
	  this.$options=options
	  this.$data =options.data
	  observe(this.$data)对数据进行响应式处理
	  proxy(this) data 数据代理到vm
	  new Compiler(option.el ,this)
  }
} 
     function observe(obj){
     if(typeof(obj)!=='object'){
	     return
      }
      new Observer(val)
     }
     class Observer{
      constructor(val){
	      this.val=val
	      this.walk(val)
      }
      walk(obj){
      //遍历对象每一层 增加oberve
	      Object.keys(obj).forEach((key)=>{
	      defineReactive(obj,key.obj[key])})
	      }
      }
   
   class Compiler{
      constructor(el,vm){
	      this.$vm=vm
	     this.$el=document.queryselector(el)
	     if(this.$el){
	     this.compile(this.$el)
	     }
      }
      compile(el){
		 const childNodes=el.childNodes;
		 Array.from(childNodes).forEach(node=>{
		 if(this.iselement(node)){
		 
			 // compile 编译node节点
			 node.nodetype=1
		 }else if(this.isInterpolation(node)){ //插值
			 //{{a}}
			  // compile解析插值的文本
		 }
		 if(node.childNodes &&node.childNodes.length>0){
		 this.complie(node)
		 }
	
	 
	 })
	 }
```
依赖的收集过程
1 定义响应式defineReactive时 针对data创建 key 根据key创建dep实例
2 针对name1的key创建watcher
3 name1 发生变化触发getter 将watcher放到name1的dep
4 name1 更新触发setter 根据dep触发watcher的更新
	      
  依赖收集实现

	      //创建依赖
```
	    <p>{{name1}}</p>
	      <p>{{name2}}</p> 
	       <p>{{name3}}</p>
	    关联key
	    key=name1 watcher1
	    key=name2 watcher2
	    key=name3 watcher3
	    Dep1 deps=[watcher1,watcher3]
         Dep1 deps=[watcher2]
         1 defineReactive 为key创建dep实例
         2  key=name1 watcher1
         3 getter 获取name1 watcher1放到name1的deps
         4 setter deps通知watcher1进行更新
	     class Watcher(vm,key,updater){
		    constructor{
				    this.vm=vm
				    this.key=key
				    this.updataFn=updater
				    //创建实例时 把当前实例指定到Dep.target
				    Dep.target=this
				    vm[key]
				    Dep.target=null
			}
			//如果更新到dom
			update(){
			this.updataFn.call(this.vm,this.vm[this.key])
			} 
	
	     }
        class Dep{
		    constructor{
				    this.dep=[]
			}
			adddep(dep){//添加依赖
			 this.dep.push(dep)
			}
			notify(){//触发更新
				 this.dep.forEach(dep=>{dep.update() })
			}
		}
		function defineReactive(obj,key.val){
		const dep = new Dep()
		object.defineProperty(data,key,{
		  get(){
				  Dep.target&&dep.addDep(Dep.target)//Dep.target是watcher的实例
		     }
	     set(newVal){
		     if(newVal === val)return 
		     dep.notify()
	     } 
		
		})
		}

```



    
 - 响应式出路
 - vuex的场景 属性
 - 动态路由 
 - 路由拦截 
 - 路由的hash模式和history模式区别
 - **Hash模式：**

1. **URL结构：** 在Hash模式下，路由信息会被存放在URL的哈希部分（即#后面），例如：`http://example.com/#/path/to/page`。
    
2. **浏览器兼容性：** Hash模式兼容性良好，支持所有现代浏览器。
    
3. **实现原理：** 当URL的哈希部分发生变化时，浏览器不会向服务器发送请求，而是通过hashchange事件来监听URL的变化，然后根据哈希值来动态更新页面内容。
    
4. **优点：** Hash模式在实现简单，且兼容性良好，在不支持HTML5 History API的浏览器中也可以正常使用。
    
5. **缺点：** URL中的#号可能会影响SEO，且在某些情况下会导致页面定位不准确。
    

**History模式：**

1. **URL结构：** 在History模式下，路由信息会被直接存放在URL的路径部分，例如：`http://example.com/path/to/page`。
    
2. **浏览器兼容性：** History模式需要浏览器支持HTML5 History API，因此在一些较老的浏览器中兼容性不佳。
    
3. **实现原理：** History模式利用HTML5 History API中的pushState()和replaceState()方法来操作浏览器历史记录，实现页面的跳转和状态的保存。
    
4. **优点：** History模式可以更加友好地展示URL，不会影响SEO，且可以使用更加传统的URL结构。
    
5. **缺点：** History模式在一些较老的浏览器中可能会出现兼容性问题，需要使用polyfill进行兼容处理。
 - 路由传参
 - 生命周期的理解
   -  vue的实例从创建到销毁的过程
   1. 创建
   2. 初始化数据
   3. 编译template
   4. 挂载dom
   5. 渲染
   6. 更新渲染
   7. 卸载
   2 生命周期钩子
   - beforecreate  实例创建之初 初始化插件
   - creaed 组件已经创建完成 异步请求的获取 dom并没有生成
   - beforemounted 组件挂载之前
   - mounted 组件挂载之后 dom已经生成 异步请求获取会导致页面闪烁
   - beforeupdate 数据发生变化 更新之前 获取更新前的状态I
   - updated 数据发生变化更新后
   - beforedestory 实例销毁前
   - destoryed 销毁后
   - activated keep-alive 组件激活
   - deactivated keep-alive 组件停用
   - errorcaptured 捕获实例的错误
   - 3生命周期：

1. **`setup`**：
    
    - `setup` 是 Vue 3 中新增的生命周期函数，用于替代 Vue 2 中的 `beforeCreate` 和 `created` 钩子函数。
    - 在 `setup` 中，你可以进行组件的初始化工作，包括响应式数据的设置、计算属性、监听器等。
    - `setup` 函数可以返回一个对象，包含组件中需要用到的数据、方法等。
2. **`onBeforeMount`**：
    
    - 在组件挂载之前调用。相当于 Vue 2 中的 `beforeMount` 钩子函数。
3. **`onMounted`**：
    
    - 在组件挂载之后调用。相当于 Vue 2 中的 `mounted` 钩子函数。
4. **`onBeforeUpdate`**：
    
    - 在组件更新之前调用。相当于 Vue 2 中的 `beforeUpdate` 钩子函数。
5. **`onUpdated`**：
    
    - 在组件更新之后调用。相当于 Vue 2 中的 `updated` 钩子函数。
6. **`onBeforeUnmount`**：
    
    - 在组件卸载之前调用。相当于 Vue 2 中的 `beforeDestroy` 钩子函数。
7. **`onUnmounted`**：
    
    - 在组件卸载之后调用。相当于 Vue 2 中的 `destroyed` 钩子函数。
8. **`onErrorCaptured`**：
    
    - 当子孙组件抛出错误时调用。相当于 Vue 2 中的 `errorCaptured` 钩子函数。
 ```
	   new vue()
	   const vm= new Vue() {}//创建空的实例
    源码 init 给实例对象注入event +lifecycle
	 // 调用beforecreated 
	  init 响应式reactivity 数据data已初始化 injection 注入属性 内置方法methods
	  // created 可以调用
	  判断element是不是有option
	  yes
	  false el option vm.$mount(el)
	    判断element是不是有template 
	   - yes compile
	   - no  el outerhtml as template
	   解析模板语言
	  // beforemount 此时模板已经编译好 但是页面未更新
	  vm.$el replace $el 生成的模板字符串替换到页面上
	  // mounted 在dom上进行渲染完成
	  更新
	  //beforeupdate 收集要更新的数据
	  虚拟dom re-render 同时进行patch
 	  // updated 页面数据已经是最新的了
	  //beforedestory
	  data method filter directive（指令） 全都可用
	  // destoryed 
	  都不可用
```
	  
	  
	




 - v-if v-show 区别
  1. 控制手段 v-show display none 元素还在  v-if dom整个删掉
  2. 编译过程 v-if 会有局部编译 卸载的过程 比v-show消耗成本大
  3. 编译条件 v-show false-true 不会触发组件的生命周期
                     v-if false-true 会触发 beforecreate create beforemount
                            true-false  会触发beforedestory destory
   
 - vue的修饰符有哪些
  限定类型或限定类型成员的符号 
  dom事件的细节
  五类修饰符
		1.  表单修饰符 v-model lazy trim number
			  v-model.lazy onchange后触发
			  v-model.trim 缩略空格
			   v-model.number 限制number
		2. 事件修饰符stop prevent self once native
		     @click.stop 阻止冒泡
		     @submit.prevent 阻止默认提交
		     v-on:click.self只有当前元素触发
		 3. 鼠标修饰符 left right middle
		 4. 键盘修饰符 onkeyup onkeydown
		 5.  keycode enter tab space esc up down
		 
 - created mounted 请求数据区别
	   created异步请求数据 没有更新到页面 mounted更新数据会更新到页面 页面闪动
 - 组件通信方式
    父子  props 子往父$emit ref  
    兄弟 eventbus  创建全局bus 通过$emit触发 $on接受 有共同祖先
```
this.$parent.$emit()
this.$parent.$on()
```
    祖孙后代
    传递给子孙
    attrs listener
```
<p>{{$attrs.foo}}</p>
<Child foo="foo"/>
//隔代传递
<Child2 msg=“hello" @some-event="onsomeEvent"/>
<GrandSon v-bind="$attrs" v-on="$listeners"/>

<div @click = $emit('some-event','sdasdasd')>	
provide inject
祖先提供provide  子孙通过inject
provide(){
	return {
		foo:'ddd'
	}
}
inject:['foo']
vuex 适合没关联的组件进行通信
```
    非关系组件
   
 - keep-alive是什么 怎么用
    vue内置组件 在组建切换过程中 状态保存在内存
      props包括
      include 支持字符串正则
      exclude 匹配不被缓存的组件
      max 最多缓存的实例数
```
<keep-alive include='a/b'>
 <component :is="view"></component>
</keep-alive>

```
		匹配时检查组件内部 name 没有---》匹配component的名称 ----》匿名组件不匹配
		设置keep-alive后会多activated deactiveted两个生命周期
		首次进入组件 beforerouterenter-》beforecreated-》created》mounted-》activated-》beforerouterleave》deactivated
		再次进入组件beforerouterenter-》activated-》beforerouterleave》deactivated
 
 使用场景
 
 


  
 - axios怎么封装的
 - 怎么解决刷新后二次加载路由
 - computed watch 区别
     1. computed是计算 watch是监听data
     2. computed 支持缓存  值变了才会重新计算 watch不支持
     3. computed不支持异步 watch可以
     4. computed第一次加载就有值 watch不是
     5. computed必须有返回值 watch不是
     
 - vuex的响应式处理
 - 封装一个组件
 - 封装可复用组件需要满足什么
 - 怎么强制刷新
 - 3和2区别
 -   1. 双向数据绑定原理不同 2是defineproperty 3是proxy
 -   2. 2支持一个根节点 3支持多个根节点
 -   3  api不同 2是选项式api 3是组合式api 组合更简洁
 -   4 定义数据变量方法不同 3有setup 组件初始化触发 返回响应数据
 -   5 生命周期不同 3 setup onbeforemounted onbeforeupdate onupdated
 -   6 传值不同 2用prop emit 3 用setup（，{emit} ）
 -   7指令插槽不同 3 v-slot v-if是v-for的判断
 -   8 main。js 2可以改原型 引入构造函数 3使用工程函数 没有根标签

 多了teleport
 原来toast modal需要嵌在组件内部 组件层级嵌套深 难用
 teleport关联指定dom节点可以直接用
createrender 创ke建渲染器
render在组建内动态的生成虚拟dom
composition  api
setup ref reactive
beforecreate setup
created setup
beforemounted onbeforemount onbeforeupdate
mounted onmounted updated
onbeforeunmount onunmounted

插槽从slot 变成$slots
v-enter ->v-enter-from
v-leave->v-leave-from
类不一样
data 2是对象或函数 3是函数
3中根节点的outerhtml-》innerhtml
$on $once $off $destroy


 - vue性能优化怎么做
		 -    编码优化
		 -          不要所有数据都放data  每个getter setter 增加性能
		 -           v-for给每个元素绑定事件用事件代理
		 -          keep-alive缓存组件
		 -          拆分组件提高复用性可维护性
		 -           key值保证唯一
		 -           合理使用路由懒加载 一部组件
		 -           数据持久化使用防抖或节流优化
		 - 加载优化
		 -        按需加载 
		 -       内容懒加载
		 -       图片懒加载
		 - 用户体验
		 -       骨架屏
		 -seo优化
		        预渲染
		       服务端渲染ssr
		打包优化
		      cdn加载第三方模块
		      多线程的打包
		      抽离公共文件
		缓存压缩
		      客户端缓存 服务端缓存
		      服务端gzip压缩
 - 
 - 
 - 首屏优化怎么做
    1. 使用路由懒加载 
    2. 非首屏组件使用异步组件
    3. 首屏不重要的组件延迟加载
    4. 静态资源放在cdn
    5. 减少首屏js css的资源文件大小 压缩文件
    6. 使用服务端渲染
    7. 尽量减少dom数量、层级
    8. 使用精灵图减少请求
    9. 做一些loading
    10. 开启gzip压缩
    11. 图片懒加载
     
 - props data 谁优先级更高

vue3
- 3的性能为啥比2好
- Vue 3 相对于 Vue 2 在性能方面有一些改进和优化，这些改进主要是通过优化虚拟 DOM 和渲染引擎来实现的。以下是 Vue 3 相对于 Vue 2 的一些性能优势：

1. **虚拟 DOM 的优化：**
   - **静态树提升：** Vue 3 引入了静态树提升（Static Tree Hoisting）机制，将静态的部分提升为常量，减少了重新渲染和对比的次数，从而提高了性能。
   - **Fragment 支持：** Vue 3 支持 Fragment，可以直接返回多个相邻的根节点，而无需额外的容器元素，减少了 DOM 操作的次数。
   - **Teleport 组件：** Vue 3 引入了 Teleport 组件，可以将子节点渲染到 DOM 中的任意位置，从而减少了重新创建组件实例的开销。

2. **编译器的优化：**
   - **模板编译优化：** Vue 3 的编译器进行了优化，生成的代码更加精简和高效，减少了初始化和渲染的时间。
   - **更好的 Tree-shaking：** Vue 3 的模块化设计和 Tree-shaking 技术使得构建时可以更好地剔除无用的代码，减少了打包后的体积，提高了加载速度。

3. **响应性系统的优化：**
   - **Proxy 替代 Object.defineProperty：** Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，使得响应性系统更加高效和灵活。
   - **优化的响应式追踪：** Vue 3 对响应式追踪进行了优化，减少了不必要的追踪和更新操作，提高了性能。

4. **TypeScript 支持：**
   - **更好的类型检查和自动补全：** Vue 3 使用 TypeScript 重写，提供了更好的类型检查和自动补全，减少了代码的错误和调试时间。

综上所述，Vue 3 相对于 Vue 2 在虚拟 DOM、编译器、响应性系统和 TypeScript 支持等方面进行了一系列优化和改进，从而提高了性能和开发体验。这些改进使得 Vue 3 在渲染速度、初始化时间和打包体积等方面都有所提升，因此相对于 Vue 2 来说，Vue 3 的性能更好。

- 为啥使用proxy
- Vue 3 使用 Proxy 主要是为了改进其响应性系统。在 Vue 2 中，Vue 使用了 Object.defineProperty 来实现响应式数据，但是 Object.defineProperty 有一些限制，比如无法监听数组的变化、无法监听动态添加的属性等。而 Proxy 对象提供了更强大和灵活的拦截功能，能够完全覆盖 Object.defineProperty 的功能，并且更适合用于实现响应式数据。

以下是 Vue 3 使用 Proxy 的几个优势和用途：

1. **监听数组的变化：** Vue 3 使用 Proxy 可以监听数组的变化，包括对数组元素的增删改操作，使得 Vue 可以更精确地跟踪数组的变化，实现更好的响应式效果。

2. **监听动态添加的属性：** Proxy 可以监听动态添加的属性，包括对新添加属性的读取和设置操作，使得 Vue 3 能够实时响应动态添加的属性。

3. **监听嵌套对象的变化：** Proxy 可以深度监听对象的属性，包括嵌套对象的属性变化，使得 Vue 3 可以更准确地响应嵌套对象的变化。

4. **性能优化：** 使用 Proxy 相比 Object.defineProperty 有更高的性能，特别是在对多个属性进行监听时，Proxy 的性能优势更为明显。

5. **更好的扩展性：** Proxy 提供了更灵活的拦截功能，能够满足更复杂的业务需求，并且更容易扩展和定制。

综上所述，Vue 3 使用 Proxy 替代 Object.defineProperty 来实现响应式数据，主要是为了提供更强大、更灵活和更高性能的响应式系统，使得 Vue 3 在处理响应式数据时更加准确、高效和可靠。
- 实现组件异步加载
- 

-
js
- 内置对象
- 闭包 
- 闭包是指在一个函数内部定义的函数可以访问该函数的作用域，即使在该函数执行完成之后，这些内部函数仍然可以访问其父函数的变量和参数。
 闭包的应用包括但不限于：
	- 封装私有变量和方法
	- 延迟执行
	- 实现模块化
	- 防止变量污染等
- 事件委托
-      
	事件委托（Event Delegation）是一种常见的 JavaScript 编程模式，用于处理事件监听和事件触发。它的核心思想是将事件处理器绑定到一个父元素上，而不是直接绑定到子元素上，然后利用事件冒泡的机制，通过父元素来管理子元素上的事件。
	
	事件委托的工作原理如下：
	
	1. 将事件处理器绑定到父元素上，通常是在最外层容器或者是父级元素上。
	2. 当事件在子元素上触发时，事件会向上冒泡到父元素。
	3. 父元素捕获到事件后，通过事件对象中的目标元素（`event.target`）来判断触发事件的具体子元素。
	4. 根据目标子元素的特征，执行相应的逻辑。
	
	使用事件委托的好处包括：
	
	- 减少内存消耗：如果有很多子元素需要绑定相同的事件处理器，直接在父元素上绑定处理器可以减少内存消耗。
	- 动态添加元素：对于动态生成的元素，无需单独为它们绑定事件处理器，直接利用委托机制即可。
	- 简化代码逻辑：通过委托机制，可以更简洁地管理事件处理逻辑，减少重复代码。
- 操作数据的方法
- 原型链
-    
	原型和原型链是 JavaScript 中一个重要的概念，对于理解 JavaScript 的对象和继承机制非常关键。让我简单地解释一下：
	
	1. **原型 (Prototype)**:
		
		- 在 JavaScript 中，每个对象都有一个原型。原型可以是另一个对象或者 `null`。
		- 对象可以从其原型继承属性和方法。
		- 当你创建一个新对象时，这个对象会自动关联到一个原型上。你可以通过 `Object.create()` 方法来明确指定对象的原型，或者通过构造函数和 `class` 关键字来创建对象，它们会自动使用相关联的原型。
	2. **原型链 (Prototype Chain)**:
		
		- 原型链是由一系列对象组成的链，每个对象都有一个原型，而原型又可以有自己的原型，如此循环直到 `null`。
		- 当你访问一个对象的属性或方法时，JavaScript 引擎首先会在对象本身查找，如果找不到，它会沿着原型链向上查找，直到找到属性或方法为止，或者直到原型链的末端（`null`）。
- 
- new操作符具体做了什么
- 继承的实现
	-   1. **原型链继承**：
	    - 原型链继承是通过让子类的原型对象指向父类的实例来实现继承的。
	    - 缺点是子类共享父类原型上的属性和方法，如果子类对父类原型上的属性进行修改，会影响到所有子类的实例。
	    -2. **构造函数继承**：
	    - 构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承的。
	    - 缺点是无法继承父类原型上的属性和方法，每个子类实例都会创建自己的一份。
	    - 3. **组合继承**：
	    - 组合继承是结合了原型链继承和构造函数继承的方式，通过调用父类构造函数来继承属性，通过将子类的原型对象指向父类的实例来继承方法。
	    - 缺点是会调用两次父类构造函数，造成不必要的性能开销。
	    - 4. **原型式继承**：
	    - 原型式继承是通过浅复制一个对象来创建一个新的对象，然后修改新对象的属性来实现继承。
	    - 缺点是无法实现真正意义上的封装和继承，会导致对象之间的引用关系混乱。
	    - 5. **寄生式继承**：
	    - 寄生式继承是在原型式继承的基础上增强了对象，返回一个增强后的对象。
	    - 缺点与原型式继承相同，容易导致对象之间的引用关系混乱。
- 设计原理
- this的指向
- async和defer的区别
- es5和es6的区别
- es6的新特性
- call apply bind的区别
- `   call`、`apply` 和 `bind` 是 JavaScript 中用于改变函数执行上下文的方法，它们有一些相似之处，但也有一些区别。

	1 **call**:
	    - `call` 方法允许你调用一个函数，并将一个指定的 `this` 值和一个或多个参数传递给该函数。
	    - `call` 方法的语法是 `function.call(thisArg, arg1, arg2, ...)`
	    - `thisArg` 参数是在调用函数时作为 `this` 关键字使用的值。
	    - `call` 方法可以传递一个参数列表作为函数的参数，每个参数都会依次传递给函数。
	    - 2. **apply**:
	    - `apply` 方法与 `call` 类似，但是它接收的是一个包含参数的数组或类数组对象。
	    - `apply` 方法的语法是 `function.apply(thisArg, [argsArray])`
	    - 3. **bind**:
	    - `bind` 方法创建一个新函数，当被调用时，将其 `this` 关键字设置为提供的值，并在调用新函数时，将其参数列表作为原始函数的参数序列的前几项。
	    - `bind` 方法的语法是 `function.bind(thisArg, arg1, arg2, ...)`
	    - - `call` 和 `apply` 立即执行函数，而 `bind` 返回一个新的函数。
	- `call` 和 `apply` 的区别在于参数的传递方式，`call` 是一个个传递，而 `apply` 则是通过数组传递。
	- `bind` 绑定函数的执行上下文，并返回一个新的函数，新函数的 `this` 值已被绑定。
- 递归的问题及解决方案
- 深拷贝的实现
- function deepCopy(obj) {
    // 判断是否为对象
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    // 根据类型创建空对象或数组
    const newObj = Array.isArray(obj) ? [] : {};
    
    // 递归复制属性
    for (let key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            newObj[key] = deepCopy(obj[key]);
        }
    }
    
    return newObj;
}

- 事件循环事件循环是 JavaScript 运行时环境中处理异步任务的核心机制。JavaScript 是单线程的语言，意味着它一次只能执行一个任务。而事件循环通过一种非阻塞的方式来处理异步任务，使得 JavaScript 在执行过程中能够同时处理多个任务，从而提高了性能和响应速度。

事件循环的机制如下：

1. **任务队列（Task Queue）：** JavaScript 运行时环境维护着一个任务队列，用于存放需要执行的任务。

2.

**事件轮询（Event Loop）：** JavaScript 运行时环境会不断地从任务队列中取出任务执行，并且不断地循环这个过程，这就是事件循环的过程。在每一轮循环中，JavaScript 运行时环境会执行以下几个步骤：

   a. 从任务队列中取出一个任务执行。
   
   b. 如果任务队列为空，则进入等待状态，等待新的任务加入。
   
   c. 执行微任务（Microtask）。在每次任务执行完成后，JavaScript 运行时环境会检查是否存在微任务队列（Microtask Queue），如果存在，则依次执行微任务队列中的任务，直到微任务队列为空。微任务包括 Promise 回调函数、MutationObserver 回调函数等。
   
   d. 如果存在用户交互事件（如点击事件、键盘事件等），则将其加入到任务队列中，等待执行。
   
   e. 如果存在定时器到期的任务，则将其加入到任务队列中，等待执行。
   
   f. 重复上述步骤，直到任务队列为空。

事件循环的优点：

- **非阻塞：** 事件循环采用非阻塞的方式处理异步任务，使得 JavaScript 能够同时处理多个任务，提高了性能和响应速度。
  
- **提高用户体验：** 通过异步任务的处理，能够提高用户体验，使得页面更加流畅和响应快速。

事件循环的缺点：

- **回调地狱（Callback Hell）：** 大量的嵌套回调函数可能导致代码可读性和维护性降低，造成回调地狱问题。

- **无法控制任务执行顺序：** 由于异步任务的执行顺序取决于任务队列中的顺序，因此无法像同步代码那样精确控制任务的执行顺序。

综上所述，事件循环是 JavaScript 异步编程的核心机制，通过任务队列和事件轮询实现了非阻塞的异步任务处理方式，从而提高了性能和响应速度，但也存在回调地狱和无法精确控制任务执行顺序等缺点。
- 
- 事件循环调用机制 异步io
		优点 
		可以处理高并发的io
		事件驱动
		可以根据进入队列的顺序 高并发处理事件
		
		node是单线程 不适合单核cpu io密集型应用
		代码发生问题 容易整个项目崩溃
- get和post的区别
- 1. **数据传输方式**:
    
    - **GET**：通过 URL 的查询字符串传输数据，在 URL 中以键值对的形式将数据附加在 URL 后面，例如 `http://example.com/path?name=value&age=30`。
    - **POST**：通过请求体传输数据，数据被包含在请求体中发送给服务器。
2. **安全性**:
    
    - **GET**：由于数据是以明文形式出现在 URL 中，所以不适合传输敏感信息，如密码等。GET 请求的数据会被浏览器缓存和历史记录中，因此不适合传输敏感信息。
    - **POST**：POST 请求的数据在请求体中，相对于 GET 请求更加安全，因为它不会出现在 URL 中。
3. **数据长度限制**:
    
    - **GET**：由于 URL 长度的限制，GET 请求传输的数据量有限制，通常在 2KB 到 8KB 之间，不同浏览器有所差异。
    - **POST**：POST 请求在理论上没有数据长度的限制，可以传输大量的数据。
4. **缓存**:
    
    - **GET**：GET 请求的数据会被浏览器缓存，可以被缓存下来。
    - **POST**：POST 请求的数据不会被浏览器缓存。
5. **幂等性**:
    
    - **GET**：GET 请求是幂等的，即无论请求多少次，对服务器的状态没有影响。即使请求具有相同的查询字符串，服务器的状态也不会改变。
    - **POST**：POST 请求不是幂等的，即多次重复发送相同的 POST 请求，可能会导致服务器的状态发生改变。

**选择**：

- 如果是用于获取数据，且不涉及敏感信息传输，一般会选择使用 GET 请求。
- 如果是用于提交表单数据或其他需要传输敏感信息或大量数据的场景，会选择使用 POST 请求。


- promise的原理和优缺点
- "Promise"（承诺）是JavaScript中的一种异步编程模式，用于处理异步操作。其原理是基于“承诺（Promise）”对象，它表示一个异步操作的最终完成（或失败）及其结果值。

在传统的回调函数中，处理异步操作时会导致代码变得复杂和难以维护，因为需要处理多个嵌套的回调函数。而使用Promise可以更清晰地表达异步操作，并且可以更容易地进行错误处理和链式调用。

Promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。一旦Promise的状态从pending转变为fulfilled或rejected，就会调用相应的处理程序（即then()方法的回调函数），并传递相应的值。

Promise的基本原理可以概括如下：

1. 创建Promise对象：通过new关键字创建一个Promise对象，其构造函数接受一个执行器函数，该函数会立即执行。

2. 执行器函数：执行器函数接受两个参数，resolve和reject，它们是由JavaScript引擎提供的回调函数。在执行器函数中执行异步操作，并根据操作的结果调用resolve或reject。

3. 状态转变：当执行器函数中调用resolve时，Promise的状态会从pending转变为fulfilled，并传递一个值作为参数；当调用reject时，状态会从pending转变为rejected，并传递一个错误对象作为参数。

4. 处理结果：通过then()方法添加处理程序，可以分别处理成功和失败的情况。then()方法接受两个参数，第一个参数是处理成功情况的回调函数，第二个参数是处理失败情况的回调函数。

5. 链式调用：Promise对象的then()方法返回一个新的Promise对象，使得可以通过链式调用的方式处理多个异步操作。

6. 错误处理：通过catch()方法或在then()方法中添加第二个参数的方式，可以捕获Promise链中任何一个Promise对象的错误。

通过这种方式，Promise提供了一种更清晰、更可靠的方式来处理异步操作，使得代码更易于理解和维护。

**优点：**

1. **更清晰的异步流程控制：** Promise提供了一种更直观和可读的方式来处理异步操作，避免了回调地狱（Callback Hell）的问题，使得代码结构更清晰。
    
2. **更容易的错误处理：** Promise允许通过链式调用的方式对多个异步操作进行组合，并且可以在链中任何一个环节进行错误处理，使得错误处理更加灵活和可靠。
    
3. **更容易的并行操作：** Promise支持多个异步操作并行执行，当所有操作都完成时，Promise链才会继续执行，这种方式更加高效。
    
4. **链式调用：** Promise的then()方法返回一个新的Promise对象，可以方便地进行链式调用，使得代码更加优雅和易于理解。
    

**缺点：**

1. **无法取消：** 一旦创建了Promise对象，就无法取消它，这可能会导致一些资源的浪费，特别是在处理长时间运行的操作时。
    
2. **无法中断：** 与取消类似，一旦Promise链开始执行，就无法中断它，这可能会导致一些性能上的问题，特别是在处理大量的并行操作时。
    
3. **错误处理需要额外注意：** 虽然Promise提供了更容易的错误处理机制，但仍然需要额外注意，特别是在忽略错误处理时可能会导致未捕获的异常。
    
4. **不是所有库和API都支持Promise：** 一些旧的库和API可能仍然使用回调函数来处理异步操作，这就需要额外的工作来将它们与Promise兼容。
- promise async await 区别
  **async/await：**

1. **基于语法糖：** async/await是一种语法糖，用于更方便地处理Promise对象。
    
2. **异步函数：** async关键字用于声明一个异步函数，使得函数内部可以使用await关键字来等待Promise对象的状态变化。
    
3. **同步风格：** async/await使得异步代码可以以同步的方式编写，更加清晰易读。
    
4. **错误处理：** 使用try/catch语句可以方便地处理异步操作中的错误，使得错误处理更加直观。
    

**区别：**

1. **编写风格：** Promise是基于链式调用的方式，而async/await是基于同步风格的方式，可以更方便地编写异步代码。
    
2. **错误处理：** async/await使用try/catch语句来处理错误，更加直观和简洁；而Promise通过.catch()方法来捕获错误。
    
3. **语法：** async/await是ES7中引入的语法糖，使用起来更加简洁明了，特别适合处理复杂的异步操作；而Promise是ES6中引入的标准，使用起来相对更加底层。

- 防抖 节流
	- 防抖（Debouncing）和节流（Throttling）是用于优化 JavaScript 中频繁触发的函数的两种常见技术。它们都可以有效地减少函数的执行次数，提高性能，但在不同的场景下有不同的应用。
	
	1. **防抖（Debouncing）**:
	    - 防抖是指在连续触发事件时，只在事件停止触发一段时间后才执行一次函数。如果在指定的时间间隔内又有事件被触发，则会重新开始计时。
	    - 防抖适用于需要等待一段时间后才执行的操作，比如搜索框输入、窗口大小调整等场景。
	    - 2. **节流（Throttling）**:
    - 节流是指在一定时间间隔内只执行一次函数。无论事件触发频率多高，每隔一段时间执行一次函数。
    - 节流适用于需要控制函数执行频率的场景，比如滚动事件、鼠标移动事件等。
    - - 防抖适用于等待事件停止后执行一次操作的场景，而节流适用于控制函数的执行频率，避免函数过于频繁地执行。
	- 在防抖中，只有在事件停止触发一段时间后才会执行函数；而在节流中，函数会按照一定的时间间隔执行，无论事件触发频率如何。

- 大文件上传
- rem的适配
- 移动端的兼容问题
- promise如何一次进行多个请求
- 延迟加载的方式
- 有哪些数据类型
- null和undefined的区别
- 对json的理解
- 如何判断对象是空对象
- 数组去重

项目
- 对组件的理解
- 1. **封装性：** 组件将页面中的不同部分封装成独立的单元，每个组件都有自己的功能和样式，使得代码更加模块化、可维护。
    
2. **可重用性：** 组件是可重用的，可以在不同的地方多次使用。通过组件的复用，可以减少重复编写相似的代码，提高开发效率。
    
3. **可组合性：** 组件可以嵌套和组合在一起，形成更复杂的界面。通过组件的组合，可以构建出丰富多样的用户界面，实现功能的复杂化。
    
4. **独立性：** 组件是相互独立的，组件之间的状态和行为互不影响。这种独立性使得组件更易于测试和维护。
    
5. **通信机制：** 组件之间可以通过props（属性）和events（事件）进行通信。props用于父组件向子组件传递数据，而events用于子组件向父组件传递数据或触发行为。
    
6. **生命周期：** 组件具有生命周期，包括挂载（mount）、更新（update）和卸载（unmount）等阶段。在不同的生命周期阶段，组件可以执行特定的操作，如初始化状态、发送网络请求、清理资源等。
    
7. **状态管理：** 组件可以拥有自己的状态（state），用于存储和管理组件内部的数据。状态的变化会触发组件的重新渲染，从而更新界面。

- 怎么规划项目文件
- 是否使用过nuxt。js
- seo如何优化
- 遇到最难的问题
- 
react
- 对react的理解 特性
- super()和super(props)区别
- 受控组件和非受控组件区别，应用场景
- react的事件机制
- 事件绑定方式有哪些 区别
- 构建组件的方式 区别
- 引入css的方式 区别
- 生命周期有哪些 区别
- 组件如何通信
- 高阶组件的理解 应用场景
- 组件间过渡动画如何实现
- 项目 如何捕获错误
- refs的理解
- setstate的执行机制
- render的原理和触发时机
- realdom和virtual dom的区别 优缺点
- jsx转换成真实dom的过程
- hoc实现props
- hoc高阶组件使用技巧
- hoc定义
- react fiber
- 修改react树

webpack
- 打包和不打包区别
- Webpack的主要作用是将项目中的各种资源（JavaScript、CSS、图片等）打包成静态文件，以优化加载速度、提高性能，并且提供了模块化的开发方式。因此，使用Webpack进行打包和不打包之间存在一些明显的区别：

**使用Webpack打包的优点：**

1. **模块化开发：** Webpack支持模块化开发，能够将项目拆分成多个模块，提高代码的可维护性和可复用性。
    
2. **资源优化：** Webpack可以优化资源的加载顺序、合并、压缩等，减少HTTP请求次数和资源文件大小，从而提高页面加载速度和性能。
    
3. **代码分割：** Webpack支持代码分割，能够将代码拆分成多个块（chunks），按需加载，减少初次加载时间。
    
4. **自动化处理：** Webpack能够自动处理各种资源，如JavaScript、CSS、图片等，无需手动处理，提高开发效率。
    
5. **插件系统：** Webpack拥有丰富的插件系统，可以通过插件实现各种功能，如代码压缩、代码分析、热模块替换等。
    

**不使用Webpack打包的缺点：**

1. **手动处理资源：** 如果不使用Webpack打包，就需要手动处理各种资源文件，包括合并、压缩、优化等，增加了开发和维护成本。
    
2. **缺乏模块化：** 不使用Webpack打包意味着缺乏模块化的开发方式，难以管理和维护大型项目。
    
3. **性能问题：** 不进行资源优化可能导致页面加载速度较慢，性能下降。
    
4. **开发效率低：** 缺乏自动化处理和插件系统可能导致开发效率较低，需要手动处理各种资源文件。
    
5. **缺少代码分割：** 不使用Webpack打包无法实现代码分割，可能导致页面加载时间较长。
- 怎么打包的 babel做什么
- Webpack打包通常通过配置Webpack配置文件（如webpack.config.js）来完成。在配置文件中，可以指定入口文件、输出文件、加载器（Loader）、插件（Plugin）等信息。Webpack会根据配置文件中的配置信息，将项目中的各种资源进行打包处理，生成最终的静态文件。
- ```
- 
```
const path = require('path');

module.exports = {
  mode: 'production', // 设置打包模式为生产模式
  entry: './src/index.js', // 指定入口文件
  output: {
    filename: 'bundle.js', // 输出文件名
    path: path.resolve(__dirname, 'dist'), // 输出目录
  },
  module: {
    rules: [
      {
        test: /\.js$/, // 匹配JavaScript文件
        exclude: /node_modules/, // 排除node_modules目录
        use: {
          loader: 'babel-loader', // 使用babel-loader处理JavaScript文件
          options: {
            presets: ['@babel/preset-env'] // 使用Babel预设进行转换
          }
        }
      }
    ]
  }
};

```


html
 - 重排重绘的区别
 -   
重排（reflow）和重绘（repaint）是浏览器渲染页面时的两个重要概念，它们之间有明显的区别：

1. **重排（Reflow）：**
    
    - 重排指的是浏览器计算元素的几何属性，然后把它们放到页面上的过程。这意味着某个元素的位置、大小等属性发生了变化，浏览器需要重新计算元素的几何属性，并且重新排列它们，以确保它们在页面上正确地显示。
    - 触发重排的操作包括改变窗口大小、改变元素的位置、大小、边距、内边距、边框等任何影响布局的属性。
    - 重排是一种比较昂贵的操作，因为它会导致整个页面布局重新计算和重新绘制。
2. **重绘（Repaint）：**
    
    - 重绘指的是浏览器根据元素的样式（如颜色、背景等）重新绘制元素的过程。这意味着元素的几何属性没有变化，但是它的样式发生了变化，需要重新绘制元素。
    - 触发重绘的操作包括改变元素的背景色、字体颜色、边框颜色、文本阴影等与样式相关的属性。
    - 重绘相对于重排来说比较轻量级，因为它只涉及元素的外观，而不涉及元素的布局。
 - 
css
- css 选择器优先级
- 1. **内联样式（Inline styles）：** 使用style属性直接在HTML标签中定义的样式，它们具有最高的优先级，通常会覆盖其他样式。
    
2. **ID选择器（ID selectors）：** 通过在样式规则中使用#符号定义的ID选择器。ID选择器的优先级高于类选择器和元素选择器。
    
3. **类选择器、属性选择器和伪类选择器（Class selectors, Attribute selectors, Pseudo-class selectors）：** 这些选择器根据元素的类、属性或状态来选择元素，并且优先级相等。
    
4. **元素选择器（Element selectors）：** 根据HTML元素类型来选择元素的选择器，具有最低的优先级。
    

如果两个样式具有相同的优先级，则后面出现的样式将覆盖先前的样式。例如，如果在一个样式表中定义了元素选择器为p的样式，然后在另一个样式表中定义了类选择器为.p的样式，那么类选择器的样式将覆盖元素选择器的样式。

此外，还有一些情况需要注意：

- **!important：** 通过在样式规则中使用!important关键字，可以提高样式的优先级。但是，过度使用!important可能会导致样式表变得难以管理，应谨慎使用。
    
- **继承：** 某些样式属性是可以被继承的，例如字体样式。在这种情况下，子元素将继承父元素的样式，但是如果子元素的样式被明确地定义了，它将覆盖继承的样式。
    
- **层叠：** 当多个样式规则应用于同一个元素时，浏览器将根据层叠规则确定最终应用的样式。
- 
- 隐藏元素的方法
- px和rem的区别
- 一个元素水平垂直居中的方式
- 浮动元素的影响
浏览器
- 浏览器本地存储方式有哪些 优缺点
-   
浏览器本地存储主要有以下几种方式：

1. **Cookies（Cookie）：**
    
    - **优点：**
        - 兼容性好，支持所有主流的浏览器。
        - 可以设置过期时间，使得数据在一定时间范围内持久保存。
        - 可以通过设置路径和域名来控制访问范围。
    - **缺点：**
        - 存储容量有限，通常只有几KB到几MB。
        - 每次HTTP请求都会携带Cookies，可能会影响性能。
        - 由于明文传输和存储在客户端，存在安全风险，例如可能被窃取或篡改。
2. **Web Storage（LocalStorage 和 SessionStorage）：**
    
    - **优点：**
        - 提供了更大的存储容量，通常为5MB到10MB。
        - 可以通过JavaScript API来方便地读写数据。
        - 数据保存在客户端，不会随着HTTP请求发送到服务器，对性能影响较小。
        - 相对于Cookies，安全性更高，不会随着每次HTTP请求发送到服务器端。
    - **缺点：**
        - 存储的数据仅限于字符串类型，需要手动序列化和反序列化非字符串数据。
        - Web Storage中的数据仅限于单个源（Origin），无法跨域访问。
        - SessionStorage的数据在会话结束时会被清除。
3. **IndexedDB（Indexed Database）：**
    
    - **优点：**
        - 提供了更大的存储容量，可以存储大量结构化数据。
        - 支持事务操作和索引，可以提高数据操作的效率。
        - 可以存储复杂的数据类型，包括二进制数据。
        - 可以跨域访问。
    - **缺点：**
        - API相对复杂，学习成本较高。
        - 对于简单的数据存储，使用起来可能比较繁琐。
        - 兼容性相对较差，不同浏览器实现可能有差异。
- 浏览器存储方式
- token存在sessionstorage还是哪里
- 同源策略
安全
- 前端安全的理解
- url输入到浏览器到页面加载都发生了什么
- 跨域的几种方式
- 


